import { mkdir, rm } from "node:fs/promises";
import path from "node:path";
import { objectWithKey } from "../utils/assert.js";

export type GeneratorDestructureImport =
	| {
			destructureSymbol: string;
			filename: string;
	  }
	| {
			destructureSymbol: string;
			package: string;
	  };

export type GeneratorStarImport =
	| {
			starSymbol: string;
			filename: string;
	  }
	| {
			starSymbol: string;
			package: string;
	  };

export type GeneratorDefaultImport =
	| {
			defaultSymbol: string;
			filename: string;
	  }
	| {
			defaultSymbol: string;
			package: string;
	  };

export type GeneratorImport =
	| GeneratorDestructureImport
	| GeneratorStarImport
	| GeneratorDefaultImport;

export async function prepareOutputDirectory(outputDirectory: string) {
	await rm(outputDirectory, { recursive: true, force: true });
	await mkdir(outputDirectory, { recursive: true });
}

export class GeneratorFile {
	#destructureImports: Map<string, Array<GeneratorDestructureImport>> = new Map();
	#starImports: Map<string, Array<GeneratorStarImport>> = new Map();
	#defaultImports: Map<string, Array<GeneratorDefaultImport>> = new Map();

	#uniqueSymbolCounter = 0;
	#chunks: Array<string> = [];

	#deferList: Array<() => void> = [];
	#beforeToStringList: Array<() => void> = [];

	constructor(public relativePath: string) {}

	defer(cb: () => void) {
		this.#deferList.push(cb);
	}

	beforeToString(cb: () => void) {
		this.#beforeToStringList.push(cb);
	}

	execDefer() {
		while (this.#deferList.length) {
			this.#deferList.pop()?.();
		}
	}

	private execBeforeToString() {
		while (this.#beforeToStringList.length) {
			this.#deferList.pop()?.();
		}
	}

	addImport(generatorImport: GeneratorImport) {
		let relative = "";
		if ("package" in generatorImport) {
			relative = generatorImport.package;
		} else {
			relative = path.relative(this.relativePath, generatorImport.filename);
			relative = relative.replace(".ts", ".js");
		}

		let map: Map<string, Array<GeneratorImport>> = this.#destructureImports;
		if (objectWithKey(generatorImport, "starSymbol")) {
			map = this.#starImports;
		} else if (objectWithKey(generatorImport, "defaultSymbol")) {
			map = this.#defaultImports;
		}

		if (map.has(relative)) {
			map.get(relative)!.push(generatorImport);
		} else {
			map.set(relative, [generatorImport]);
		}
	}

	write(chunk: string, defer?: () => void) {
		this.#chunks.push(chunk);

		if (defer) {
			this.defer(defer);
		}
	}

	toString() {
		this.execBeforeToString();

		return `// Generated by @lightbase/open-api-code-gen
${this.resolveImports()}
${this.#chunks.join("\n")}
    `;
	}

	private resolveImports() {
		const result = [];

		for (const [key, generatorImports] of this.#destructureImports) {
			const symbolSet = new Set(generatorImports.map((it) => it.destructureSymbol));
			result.push(`import { ${[...symbolSet].join(", ")} } from "${key}";`);
		}

		for (const [key, generatorImports] of this.#starImports) {
			const symbolSet = new Set(generatorImports.map((it) => it.starSymbol));
			if (symbolSet.size === 1) {
				result.push(`import * as ${[...symbolSet][0]} from "${key}";`);
			} else {
				const uniqueSymbol = this.#uniqueSymbolCounter++;
				result.push(`import * as __${uniqueSymbol} from "${key}";`);

				for (const star of symbolSet) {
					result.push(`const ${star} = __${uniqueSymbol};`);
				}
			}
		}

		for (const [key, generatorImports] of this.#defaultImports) {
			const symbolSet = new Set(generatorImports.map((it) => it.defaultSymbol));
			if (symbolSet.size === 1) {
				result.push(`import ${[...symbolSet][0]} from "${key}";`);
			} else {
				const uniqueSymbol = this.#uniqueSymbolCounter++;
				result.push(`import __${uniqueSymbol} from "${key}";`);

				for (const star of symbolSet) {
					result.push(`const ${star} = __${uniqueSymbol};`);
				}
			}
		}

		return result.join("\n");
	}
}
