# Required readings

There are some things you just need to know before attempting the conversion.

## Vitest

[Vitest](https://vitest.dev/) is a modern test-framework. Decently fast. It has various
IDE integrations. The way we setup 'global'-services and how they are handled in tests,
doesn't full map to Vitest test isolation. Resulting in a slow-ish experience with full
re-setup of all services for all test suites.

There will be more material and tips later on to improve the setup to be more Vitest
native.

## TSX

[TSX](https://github.com/privatenumber/tsx) is an `npx` or `node` wrapper which
automatically transpiles TypeScript. This is used in development to import `gen/*.ts`
files while generating for example. Projects can alternatively use
[Jiti](https://github.com/unjs/jiti) or use Node.js built-in
[type-stripping](https://nodejs.org/docs/latest/api/typescript.html#type-stripping). The
last one can especially be great with the new
[`erasableSyntaxOnly`](https://github.com/microsoft/TypeScript/issues/59601)
([or on a blog](https://www.totaltypescript.com/erasable-syntax-only)) option of
TypeScript 5.8 (beta at the time of writing).

## TypeScript in general

We use all the strict-features of TypeScript, it might make sense for your project to
disable a few to start with. But as a general rule, the stricter the better. Which should
be possible, provided that the picked libraries are type-aware as well. Compas might
generate empty types `export type Foo = {}`. This empty object literal is not ideal. Read
up on why that is :). In general, when used in application code, using
`Record<string, unknown>` might make the most sense, but check on a case-by-case basis.

## Any usage

This project uses `$ConvertAny` and `TODO(compas-convert)` extensively. It is advised to
align with this when migrating the project. After the migration, it should be the goal to
clean these things up as soon as possible.

## Enums, as const, satisfies

A great deal of code and types which represent enum-likes can be improved with `as const`
or `satisfies Record<string, SomeType>`. We prefer these methods above using TypeScript
enums. There are numerous articles that reason for or against enums, look them up. In
general try to use a string union type:

```ts
export type Directions = "North" | "East" | "South" | "West";
```

Or a const object (preferred)

```ts
export const DIRECTIONS = {
	North: "North",
	East: "East",
	South: "South",
	West: "West",
} as const;

// Which also allows to extract the keys or values as types, dependending on whats important.
export type DirectionKeys = keyof typeof DIRECTIONS;
export type DirectionValues = DIRECTIONS[DirectionKeys];
```

Considering a common way how permissions are defined in Compas projects:

```ts
// Generated by Compas;
export type AuthPermissionIdentifier = "post:read" | "post:write" | "comment:read";

// In some constants file:
export const permissions: Record<string, AuthPermissionIdentifier> = {
	postRead: "post:read",
	postWrite: "post:write",
	commentRead: "comment:read",
};
```

Due to the explicit type-annotation of `Record<string,`, the compiler will complain when
accessing `permissions.postRead` since it may return `undefined`. Since not all string
keys may be defined and thus could theoretically resolve to `undefined`.

A first attempt to improve this would be to write the `permissions` as such:

```ts
export const permissions = {
	postRead: "post:read",
	postWrite: "post:write",
	commentRead: "comment:read",
} as const;
// ^ Note the `as const`. Check the type documentation in your IDE, to see what it does.
```

This correctly types the available keys and their values, so `permissions.postRead`
returns the type `"post:read"`. However, now you can add `commentWrite: "comment:write"`
to the object, which isn't a defined permission.

In these cases, the following is recommended:

```ts
export type AuthPermissionIdentifier = "post:read" | "post:write" | "comment:read";

export const permissions = {
	postRead: "post:read",
	postWrite: "post:write",
	commentRead: "comment:read",
} satisfies Record<string, AuthPermissionIdentifier>;
```

It resolves the type `as const`, so known keys return tye type `AuthPermissionIdentifier`
and never `| undefined`. And it also verifies that the const object satisfies the type
constraint, so unknown permission identifiers can't be added.

## Query builder types

Compas generates various types related to the `queryXyz` functions. These are helpers to
get a typed result. Current code mostly uses `QueryResultAuthUser` for example, which
doesn't specify any joins. So there is knowledge or research required to find out what is
joined and what isn't. The potentially joined properties are then typed as
`undefined|string|SomeJoinedResult`. It is advised to refactor those types to something
like

```ts
type AdminUser = DatabaseUserQueryResolver<{
	roles: undefined;
	adminSettings: {
		profilePicture: undefined;
	};
}>;
```

This way, you can use the `AdminUser` type instead of `QueryResultAuthUser`. This also
supports optional joins. Those will be handled in later docs.

## Error handling and other utilities

Use [@lightbase/utils](https://www.npmjs.com/package/@lightbase/utils) for type-aware
things like `isNil`. It also has branch-less error cases like `assertNotNil`.

In general, we can improve error handling a bit, using things like invariants more. Also
checkout the types that package provides.

## Explicit return types

We'd have to find some common ground on explicit or implicit return types. In general, the
community consensus is that for complex functions and/or complex return types, it makes
sense to use explicit return types. Annotating a `upperCaseFirst(str: string): string` or
explicit `Promise<void>` function isn't really necessary, but we can align on that later.

## Git Worktree

This project creates a new [Git Worktree](https://git-scm.com/docs/git-worktree). This
allows you to have multiple checkouts for the same projects. See the linked docs for
information on how to clean that up eventually.
